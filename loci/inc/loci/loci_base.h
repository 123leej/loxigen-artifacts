/* Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University */
/* Copyright (c) 2011, 2012 Open Networking Foundation */
/* Copyright (c) 2012, 2013 Big Switch Networks, Inc. */
/* See the file LICENSE.loci which should have been included in the source distribution */

/****************************************************************
 * File: loci_base.h
 *
 * DO NOT EDIT
 *
 * This file is automatically generated
 *
 ****************************************************************/


#if !defined(_LOCI_BASE_H_)
#define _LOCI_BASE_H_


/*
 * Base OpenFlow definitions.  These depend only on standard C headers
 */
#include <string.h>
#include <stdint.h>

/* g++ requires this to pick up PRI, etc.
 * See  http://gcc.gnu.org/ml/gcc-help/2006-10/msg00223.html
 */
#if !defined(__STDC_FORMAT_MACROS)
#define __STDC_FORMAT_MACROS
#endif
#include <inttypes.h>

#include <stdlib.h>
#include <assert.h>
#include <loci/loci_idents.h>

/**
 * Macro to enable debugging for LOCI.
 *
 * This enables debug output to stdout.
 */
#define OF_DEBUG_ENABLE

#if defined(OF_DEBUG_ENABLE)
#include <stdio.h> /* Currently for debugging */
#define FIXME(str) do {                 \
        fprintf(stderr, "%s\n", str);  \
        exit(1);                        \
    } while (0)
#define debug printf
#else
#define FIXME(str)
#define debug(str, ...)
#endif /* OF_DEBUG_ENABLE */

/**
 * The type of a function used by the LOCI dump/show functions to
 * output text. Essentially the same signature as fprintf. May
 * be called many times per invocation of e.g. of_object_show().
 */
typedef int (*loci_writer_f)(void *cookie, const char *fmt, ...);

/**
 * Check if a version is supported
 */
#define OF_VERSION_OKAY(v) ((v) >= OF_VERSION_1_0 && (v) <= OF_VERSION_1_3)


/**
 * Enumeration of OpenFlow versions
 *
 * The wire protocol numbers are currently used for values of the corresponding
 * version identifiers.
 */
typedef enum of_version_e {
    OF_VERSION_UNKNOWN = 0,
    OF_VERSION_1_0 = 1,
    OF_VERSION_1_1 = 2,
    OF_VERSION_1_2 = 3,
    OF_VERSION_1_3 = 4
} of_version_t;

/**
 * @brief Use this when declaring arrays indexed by wire version
 */
#define OF_VERSION_ARRAY_MAX 5


typedef enum of_error_codes_e {
    OF_ERROR_NONE        = 0,
    OF_ERROR_RESOURCE    = -1,    /* Could not allocate space */
    OF_ERROR_PARAM       = -2,    /* Bad parameter */
    OF_ERROR_VERSION     = -3,    /* Version not supported */
    OF_ERROR_RANGE       = -4,    /* End of list indication */
    OF_ERROR_COMPAT      = -5,    /* Incompatible assignment */
    OF_ERROR_PARSE       = -6,    /* Error in parsing data */
    OF_ERROR_INIT        = -7,    /* Uninitialized data */
    OF_ERROR_UNKNOWN     = -8     /* Unknown error */
} of_error_codes_t;

#define OF_ERROR_STRINGS "none", \
    "resource", \
    "parameter", \
    "version", \
    "range", \
    "incompatible", \
    "parse", \
    "init", \
    "unknown"

extern const char *const of_error_strings[];

#ifdef __GNUC__
#define LOCI_NORETURN_ATTR __attribute__((__noreturn__))
#else
#define LOCI_NORETURN_ATTR
#endif

extern void loci_assert_fail(
    const char *cond,
    const char *file,
    unsigned int line) LOCI_NORETURN_ATTR;

#ifndef NDEBUG
#define LOCI_ASSERT(val) ((val) ? (void)0 : loci_assert_fail(#val, __FILE__, __LINE__))
#else
#define LOCI_ASSERT(val)
#endif

/*
 * Some LOCI object accessors can fail, and it's easy to forget to check.
 * On certain compilers we can trigger a warning if the error code
 * is ignored.
 */
#ifndef DISABLE_WARN_UNUSED_RESULT
#ifdef __GNUC__
#define WARN_UNUSED_RESULT __attribute__ ((warn_unused_result))
#else
#define WARN_UNUSED_RESULT
#endif
#else
#define WARN_UNUSED_RESULT
#endif

typedef union of_generic_u of_generic_t;
typedef struct of_object_s of_object_t;

/* Define ipv4 address as uint32 */
typedef uint32_t of_ipv4_t;

/* Table ID is the OF standard uint8 */
typedef uint8_t of_table_id_t;

#define OF_MAC_ADDR_BYTES 6
typedef struct of_mac_addr_s {
   uint8_t addr[OF_MAC_ADDR_BYTES];
} of_mac_addr_t;

#define OF_IPV6_BYTES 16
typedef struct of_ipv6_s {
   uint8_t addr[OF_IPV6_BYTES];
} of_ipv6_t;

extern const of_mac_addr_t of_mac_addr_all_ones;
extern const of_mac_addr_t of_mac_addr_all_zeros;

extern const of_ipv6_t of_ipv6_all_ones;
extern const of_ipv6_t of_ipv6_all_zeros;

/**
 * Generic zero and all-ones values of size 16 bytes.
 *
 * IPv6 is longest data type we worry about for comparisons
 */
#define of_all_zero_value of_ipv6_all_zeros
#define of_all_ones_value of_ipv6_all_ones

/**
 * Non-zero/all ones check for arbitrary type of size <= 16 bytes
 */
#define OF_VARIABLE_IS_NON_ZERO(_ptr) \
    (MEMCMP(&of_all_zero_value, (_ptr), sizeof(*(_ptr))))
#define OF_VARIABLE_IS_ALL_ONES(_ptr) \
    (!MEMCMP(&of_all_ones_value, (_ptr), sizeof(*(_ptr))))

/* The octets object is a struct holding pointer and length */
typedef struct of_octets_s {
    uint8_t *data;
    int bytes;
} of_octets_t;

/* Macro to convert an octet object to a pointer; currently trivial */
#define OF_OCTETS_POINTER_GET(octet_ptr) ((octet_ptr)->data)
#define OF_OCTETS_POINTER_SET(octet_ptr, ptr) (octet_ptr)->data = (ptr)
#define OF_OCTETS_BYTES_GET(octet_ptr) ((octet_ptr)->bytes)
#define OF_OCTETS_BYTES_SET(octet_ptr, bytes) (octet_ptr)->bytes = (bytes)

/* Currently these are categorized as scalars */
typedef char of_port_name_t[OF_MAX_PORT_NAME_LEN];
typedef char of_table_name_t[OF_MAX_TABLE_NAME_LEN];
typedef char of_desc_str_t[OF_DESC_STR_LEN];
typedef char of_serial_num_t[OF_SERIAL_NUM_LEN];

typedef struct of_bitmap_128_s {
    uint64_t hi;
    uint64_t lo;
} of_bitmap_128_t;

typedef struct of_checksum_128_s {
    uint64_t hi;
    uint64_t lo;
} of_checksum_128_t;

/* These are types which change across versions.  */
typedef uint32_t of_port_no_t;
typedef uint16_t of_fm_cmd_t;
typedef uint64_t of_wc_bmap_t;
typedef uint64_t of_match_bmap_t;

#define MEMMOVE(dest, src, bytes) memmove(dest, src, bytes)
#define MEMSET(dest, val, bytes) memset(dest, val, bytes)
#define MEMCPY(dest, src, bytes) memcpy(dest, src, bytes)
#define MEMCMP(a, b, bytes) memcmp(a, b, bytes)
#define MALLOC(bytes) malloc(bytes)
#define FREE(ptr) free(ptr)

/** Try an operation and return on failure. */
#define OF_TRY(op) do {                                                      \
        int _rv;                                                             \
        if ((_rv = (op)) < 0) {                                              \
            LOCI_LOG_ERROR("ERROR %d at %s:%d\n", _rv, __FILE__, __LINE__); \
            return _rv;                                                      \
        }                                                                    \
    } while (0)

/* The extent of an OF match object is determined by its length field, but
 * aligned to 8 bytes
 */

#define OF_MATCH_BYTES(length) (((length) + 7) & 0xfff8)

#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#define U16_NTOH(val) (val)
#define U32_NTOH(val) (val)
#define U64_NTOH(val) (val)
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) (val)
#define U32_HTON(val) (val)
#define U64_HTON(val) (val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#else /* Little Endian */
#define U16_NTOH(val) (((val) >> 8) | (((val) & 0xff) << 8))
#define U32_NTOH(val) ((((val) & 0xff000000) >> 24) |                   \
                       (((val) & 0x00ff0000) >>  8) |                   \
                       (((val) & 0x0000ff00) <<  8) |                   \
                       (((val) & 0x000000ff) << 24))
#define U64_NTOH(val) ((((val) & 0xff00000000000000LL) >> 56) |         \
                       (((val) & 0x00ff000000000000LL) >> 40) |         \
                       (((val) & 0x0000ff0000000000LL) >> 24) |         \
                       (((val) & 0x000000ff00000000LL) >>  8) |         \
                       (((val) & 0x00000000ff000000LL) <<  8) |         \
                       (((val) & 0x0000000000ff0000LL) << 24) |         \
                       (((val) & 0x000000000000ff00LL) << 40) |         \
                       (((val) & 0x00000000000000ffLL) << 56))
#define IPV6_NTOH(dst, src) /* NOTE different syntax; currently no-op */
#define U16_HTON(val) U16_NTOH(val)
#define U32_HTON(val) U32_NTOH(val)
#define U64_HTON(val) U64_NTOH(val)
#define IPV6_HTON(dst, src) /* NOTE different syntax; currently no-op */
#endif

/****************************************************************
 *
 * The following are internal definitions used by the automatically
 * generated code.  Users should not reference these definitions
 * as they may change between versions of this code
 *
 ****************************************************************/

#define OF_MESSAGE_IN_MATCH_POINTER(obj)                            \
    (WIRE_BUF_POINTER(&((obj)->wire_buffer), OF_MESSAGE_IN_MATCH_OFFSET))
#define OF_MESSAGE_IN_MATCH_LEN(ptr) BUF_U16_GET(&ptr[2])
#define OF_MESSAGE_IN_DATA_OFFSET(obj) \
    (FIXED_LEN + OF_MESSAGE_IN_MATCH_LEN(OF_MESSAGE_IN_MATCH_POINTER(obj)) + 2)

#define OF_MESSAGE_OUT_DATA_OFFSET(obj) \
    (FIXED_LEN + of_message_out_actions_len_get(obj))



/**
 * Enumeration of OpenFlow objects
 *
 * We enumerate the OpenFlow objects used internally.  Note that some
 * message types are determined both by an outer type (message type like
 * stats_request) and an inner type (port stats).  These are different
 * messages in ofC.
 *
 * These values are for internal use only.  They will change with
 * different versions of ofC.
 */

typedef enum of_object_id_e {
    /* Root object type */
    OF_OBJECT_INVALID = -1, /* "invalid" return value for mappings */
    OF_OBJECT = 0, /* Generic, untyped object */

    /* OpenFlow message objects */
    OF_AGGREGATE_STATS_REPLY = 1,
    OF_AGGREGATE_STATS_REQUEST = 2,
    OF_ASYNC_GET_REPLY = 3,
    OF_ASYNC_GET_REQUEST = 4,
    OF_ASYNC_SET = 5,
    OF_BAD_ACTION_ERROR_MSG = 6,
    OF_BAD_INSTRUCTION_ERROR_MSG = 7,
    OF_BAD_MATCH_ERROR_MSG = 8,
    OF_BAD_REQUEST_ERROR_MSG = 9,
    OF_BARRIER_REPLY = 10,
    OF_BARRIER_REQUEST = 11,
    OF_BSN_ARP_IDLE = 12,
    OF_BSN_BW_CLEAR_DATA_REPLY = 13,
    OF_BSN_BW_CLEAR_DATA_REQUEST = 14,
    OF_BSN_BW_ENABLE_GET_REPLY = 15,
    OF_BSN_BW_ENABLE_GET_REQUEST = 16,
    OF_BSN_BW_ENABLE_SET_REPLY = 17,
    OF_BSN_BW_ENABLE_SET_REQUEST = 18,
    OF_BSN_CONTROLLER_CONNECTIONS_REPLY = 19,
    OF_BSN_CONTROLLER_CONNECTIONS_REQUEST = 20,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REPLY = 21,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_REQUEST = 22,
    OF_BSN_FLOW_IDLE = 23,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REPLY = 24,
    OF_BSN_FLOW_IDLE_ENABLE_GET_REQUEST = 25,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REPLY = 26,
    OF_BSN_FLOW_IDLE_ENABLE_SET_REQUEST = 27,
    OF_BSN_GENTABLE_BUCKET_STATS_REPLY = 28,
    OF_BSN_GENTABLE_BUCKET_STATS_REQUEST = 29,
    OF_BSN_GENTABLE_CLEAR_REPLY = 30,
    OF_BSN_GENTABLE_CLEAR_REQUEST = 31,
    OF_BSN_GENTABLE_DESC_STATS_REPLY = 32,
    OF_BSN_GENTABLE_DESC_STATS_REQUEST = 33,
    OF_BSN_GENTABLE_ENTRY_ADD = 34,
    OF_BSN_GENTABLE_ENTRY_DELETE = 35,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REPLY = 36,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_REQUEST = 37,
    OF_BSN_GENTABLE_ENTRY_STATS_REPLY = 38,
    OF_BSN_GENTABLE_ENTRY_STATS_REQUEST = 39,
    OF_BSN_GENTABLE_SET_BUCKETS_SIZE = 40,
    OF_BSN_GENTABLE_STATS_REPLY = 41,
    OF_BSN_GENTABLE_STATS_REQUEST = 42,
    OF_BSN_GET_INTERFACES_REPLY = 43,
    OF_BSN_GET_INTERFACES_REQUEST = 44,
    OF_BSN_GET_IP_MASK_REPLY = 45,
    OF_BSN_GET_IP_MASK_REQUEST = 46,
    OF_BSN_GET_L2_TABLE_REPLY = 47,
    OF_BSN_GET_L2_TABLE_REQUEST = 48,
    OF_BSN_GET_MIRRORING_REPLY = 49,
    OF_BSN_GET_MIRRORING_REQUEST = 50,
    OF_BSN_GET_SWITCH_PIPELINE_REPLY = 51,
    OF_BSN_GET_SWITCH_PIPELINE_REQUEST = 52,
    OF_BSN_HEADER = 53,
    OF_BSN_HYBRID_GET_REPLY = 54,
    OF_BSN_HYBRID_GET_REQUEST = 55,
    OF_BSN_LACP_CONVERGENCE_NOTIF = 56,
    OF_BSN_LACP_STATS_REPLY = 57,
    OF_BSN_LACP_STATS_REQUEST = 58,
    OF_BSN_PDU_RX_REPLY = 59,
    OF_BSN_PDU_RX_REQUEST = 60,
    OF_BSN_PDU_RX_TIMEOUT = 61,
    OF_BSN_PDU_TX_REPLY = 62,
    OF_BSN_PDU_TX_REQUEST = 63,
    OF_BSN_PORT_COUNTER_STATS_REPLY = 64,
    OF_BSN_PORT_COUNTER_STATS_REQUEST = 65,
    OF_BSN_ROLE_STATUS = 66,
    OF_BSN_SET_AUX_CXNS_REPLY = 67,
    OF_BSN_SET_AUX_CXNS_REQUEST = 68,
    OF_BSN_SET_IP_MASK = 69,
    OF_BSN_SET_L2_TABLE_REPLY = 70,
    OF_BSN_SET_L2_TABLE_REQUEST = 71,
    OF_BSN_SET_LACP_REPLY = 72,
    OF_BSN_SET_LACP_REQUEST = 73,
    OF_BSN_SET_MIRRORING = 74,
    OF_BSN_SET_PKTIN_SUPPRESSION_REPLY = 75,
    OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST = 76,
    OF_BSN_SET_SWITCH_PIPELINE_REPLY = 77,
    OF_BSN_SET_SWITCH_PIPELINE_REQUEST = 78,
    OF_BSN_SHELL_COMMAND = 79,
    OF_BSN_SHELL_OUTPUT = 80,
    OF_BSN_SHELL_STATUS = 81,
    OF_BSN_STATS_REPLY = 82,
    OF_BSN_STATS_REQUEST = 83,
    OF_BSN_SWITCH_PIPELINE_STATS_REPLY = 84,
    OF_BSN_SWITCH_PIPELINE_STATS_REQUEST = 85,
    OF_BSN_TABLE_CHECKSUM_STATS_REPLY = 86,
    OF_BSN_TABLE_CHECKSUM_STATS_REQUEST = 87,
    OF_BSN_TABLE_SET_BUCKETS_SIZE = 88,
    OF_BSN_TIME_REPLY = 89,
    OF_BSN_TIME_REQUEST = 90,
    OF_BSN_VIRTUAL_PORT_CREATE_REPLY = 91,
    OF_BSN_VIRTUAL_PORT_CREATE_REQUEST = 92,
    OF_BSN_VIRTUAL_PORT_REMOVE_REPLY = 93,
    OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST = 94,
    OF_BSN_VLAN_COUNTER_STATS_REPLY = 95,
    OF_BSN_VLAN_COUNTER_STATS_REQUEST = 96,
    OF_DESC_STATS_REPLY = 97,
    OF_DESC_STATS_REQUEST = 98,
    OF_ECHO_REPLY = 99,
    OF_ECHO_REQUEST = 100,
    OF_ERROR_MSG = 101,
    OF_EXPERIMENTER = 102,
    OF_EXPERIMENTER_ERROR_MSG = 103,
    OF_EXPERIMENTER_STATS_REPLY = 104,
    OF_EXPERIMENTER_STATS_REQUEST = 105,
    OF_FEATURES_REPLY = 106,
    OF_FEATURES_REQUEST = 107,
    OF_FLOW_ADD = 108,
    OF_FLOW_DELETE = 109,
    OF_FLOW_DELETE_STRICT = 110,
    OF_FLOW_MOD = 111,
    OF_FLOW_MOD_FAILED_ERROR_MSG = 112,
    OF_FLOW_MODIFY = 113,
    OF_FLOW_MODIFY_STRICT = 114,
    OF_FLOW_REMOVED = 115,
    OF_FLOW_STATS_REPLY = 116,
    OF_FLOW_STATS_REQUEST = 117,
    OF_GET_CONFIG_REPLY = 118,
    OF_GET_CONFIG_REQUEST = 119,
    OF_GROUP_ADD = 120,
    OF_GROUP_DELETE = 121,
    OF_GROUP_DESC_STATS_REPLY = 122,
    OF_GROUP_DESC_STATS_REQUEST = 123,
    OF_GROUP_FEATURES_STATS_REPLY = 124,
    OF_GROUP_FEATURES_STATS_REQUEST = 125,
    OF_GROUP_MOD = 126,
    OF_GROUP_MOD_FAILED_ERROR_MSG = 127,
    OF_GROUP_MODIFY = 128,
    OF_GROUP_STATS_REPLY = 129,
    OF_GROUP_STATS_REQUEST = 130,
    OF_HELLO = 131,
    OF_HELLO_FAILED_ERROR_MSG = 132,
    OF_METER_CONFIG_STATS_REPLY = 133,
    OF_METER_CONFIG_STATS_REQUEST = 134,
    OF_METER_FEATURES_STATS_REPLY = 135,
    OF_METER_FEATURES_STATS_REQUEST = 136,
    OF_METER_MOD = 137,
    OF_METER_MOD_FAILED_ERROR_MSG = 138,
    OF_METER_STATS_REPLY = 139,
    OF_METER_STATS_REQUEST = 140,
    OF_NICIRA_CONTROLLER_ROLE_REPLY = 141,
    OF_NICIRA_CONTROLLER_ROLE_REQUEST = 142,
    OF_NICIRA_HEADER = 143,
    OF_PACKET_IN = 144,
    OF_PACKET_OUT = 145,
    OF_PORT_DESC_STATS_REPLY = 146,
    OF_PORT_DESC_STATS_REQUEST = 147,
    OF_PORT_MOD = 148,
    OF_PORT_MOD_FAILED_ERROR_MSG = 149,
    OF_PORT_STATS_REPLY = 150,
    OF_PORT_STATS_REQUEST = 151,
    OF_PORT_STATUS = 152,
    OF_QUEUE_GET_CONFIG_REPLY = 153,
    OF_QUEUE_GET_CONFIG_REQUEST = 154,
    OF_QUEUE_OP_FAILED_ERROR_MSG = 155,
    OF_QUEUE_STATS_REPLY = 156,
    OF_QUEUE_STATS_REQUEST = 157,
    OF_ROLE_REPLY = 158,
    OF_ROLE_REQUEST = 159,
    OF_ROLE_REQUEST_FAILED_ERROR_MSG = 160,
    OF_SET_CONFIG = 161,
    OF_STATS_REPLY = 162,
    OF_STATS_REQUEST = 163,
    OF_SWITCH_CONFIG_FAILED_ERROR_MSG = 164,
    OF_TABLE_FEATURES_FAILED_ERROR_MSG = 165,
    OF_TABLE_FEATURES_STATS_REPLY = 166,
    OF_TABLE_FEATURES_STATS_REQUEST = 167,
    OF_TABLE_MOD = 168,
    OF_TABLE_MOD_FAILED_ERROR_MSG = 169,
    OF_TABLE_STATS_REPLY = 170,
    OF_TABLE_STATS_REQUEST = 171,

    /* Non-message objects */
    OF_ACTION = 172,
    OF_ACTION_BSN = 173,
    OF_ACTION_BSN_MIRROR = 174,
    OF_ACTION_BSN_SET_TUNNEL_DST = 175,
    OF_ACTION_COPY_TTL_IN = 176,
    OF_ACTION_COPY_TTL_OUT = 177,
    OF_ACTION_DEC_MPLS_TTL = 178,
    OF_ACTION_DEC_NW_TTL = 179,
    OF_ACTION_ENQUEUE = 180,
    OF_ACTION_EXPERIMENTER = 181,
    OF_ACTION_GROUP = 182,
    OF_ACTION_HEADER = 183,
    OF_ACTION_ID = 184,
    OF_ACTION_ID_BSN = 185,
    OF_ACTION_ID_BSN_MIRROR = 186,
    OF_ACTION_ID_BSN_SET_TUNNEL_DST = 187,
    OF_ACTION_ID_COPY_TTL_IN = 188,
    OF_ACTION_ID_COPY_TTL_OUT = 189,
    OF_ACTION_ID_DEC_MPLS_TTL = 190,
    OF_ACTION_ID_DEC_NW_TTL = 191,
    OF_ACTION_ID_EXPERIMENTER = 192,
    OF_ACTION_ID_GROUP = 193,
    OF_ACTION_ID_HEADER = 194,
    OF_ACTION_ID_NICIRA = 195,
    OF_ACTION_ID_NICIRA_DEC_TTL = 196,
    OF_ACTION_ID_OUTPUT = 197,
    OF_ACTION_ID_POP_MPLS = 198,
    OF_ACTION_ID_POP_PBB = 199,
    OF_ACTION_ID_POP_VLAN = 200,
    OF_ACTION_ID_PUSH_MPLS = 201,
    OF_ACTION_ID_PUSH_PBB = 202,
    OF_ACTION_ID_PUSH_VLAN = 203,
    OF_ACTION_ID_SET_FIELD = 204,
    OF_ACTION_ID_SET_MPLS_TTL = 205,
    OF_ACTION_ID_SET_NW_TTL = 206,
    OF_ACTION_ID_SET_QUEUE = 207,
    OF_ACTION_NICIRA = 208,
    OF_ACTION_NICIRA_DEC_TTL = 209,
    OF_ACTION_OUTPUT = 210,
    OF_ACTION_POP_MPLS = 211,
    OF_ACTION_POP_PBB = 212,
    OF_ACTION_POP_VLAN = 213,
    OF_ACTION_PUSH_MPLS = 214,
    OF_ACTION_PUSH_PBB = 215,
    OF_ACTION_PUSH_VLAN = 216,
    OF_ACTION_SET_DL_DST = 217,
    OF_ACTION_SET_DL_SRC = 218,
    OF_ACTION_SET_FIELD = 219,
    OF_ACTION_SET_MPLS_LABEL = 220,
    OF_ACTION_SET_MPLS_TC = 221,
    OF_ACTION_SET_MPLS_TTL = 222,
    OF_ACTION_SET_NW_DST = 223,
    OF_ACTION_SET_NW_ECN = 224,
    OF_ACTION_SET_NW_SRC = 225,
    OF_ACTION_SET_NW_TOS = 226,
    OF_ACTION_SET_NW_TTL = 227,
    OF_ACTION_SET_QUEUE = 228,
    OF_ACTION_SET_TP_DST = 229,
    OF_ACTION_SET_TP_SRC = 230,
    OF_ACTION_SET_VLAN_PCP = 231,
    OF_ACTION_SET_VLAN_VID = 232,
    OF_ACTION_STRIP_VLAN = 233,
    OF_BSN_CONTROLLER_CONNECTION = 234,
    OF_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 235,
    OF_BSN_GENTABLE_BUCKET_STATS_ENTRY = 236,
    OF_BSN_GENTABLE_DESC_STATS_ENTRY = 237,
    OF_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 238,
    OF_BSN_GENTABLE_ENTRY_STATS_ENTRY = 239,
    OF_BSN_GENTABLE_STATS_ENTRY = 240,
    OF_BSN_INTERFACE = 241,
    OF_BSN_LACP_STATS_ENTRY = 242,
    OF_BSN_PORT_COUNTER_STATS_ENTRY = 243,
    OF_BSN_SWITCH_PIPELINE_STATS_ENTRY = 244,
    OF_BSN_TABLE_CHECKSUM_STATS_ENTRY = 245,
    OF_BSN_TLV = 246,
    OF_BSN_TLV_BROADCAST_QUERY_TIMEOUT = 247,
    OF_BSN_TLV_CIRCUIT_ID = 248,
    OF_BSN_TLV_HEADER = 249,
    OF_BSN_TLV_IDLE_NOTIFICATION = 250,
    OF_BSN_TLV_IDLE_TIME = 251,
    OF_BSN_TLV_IDLE_TIMEOUT = 252,
    OF_BSN_TLV_IPV4 = 253,
    OF_BSN_TLV_MAC = 254,
    OF_BSN_TLV_MISS_PACKETS = 255,
    OF_BSN_TLV_PORT = 256,
    OF_BSN_TLV_REPLY_PACKETS = 257,
    OF_BSN_TLV_REQUEST_PACKETS = 258,
    OF_BSN_TLV_RX_PACKETS = 259,
    OF_BSN_TLV_TX_PACKETS = 260,
    OF_BSN_TLV_UNICAST_QUERY_TIMEOUT = 261,
    OF_BSN_TLV_VLAN_VID = 262,
    OF_BSN_VLAN_COUNTER_STATS_ENTRY = 263,
    OF_BSN_VPORT = 264,
    OF_BSN_VPORT_HEADER = 265,
    OF_BSN_VPORT_Q_IN_Q = 266,
    OF_BUCKET = 267,
    OF_BUCKET_COUNTER = 268,
    OF_FLOW_STATS_ENTRY = 269,
    OF_GROUP_DESC_STATS_ENTRY = 270,
    OF_GROUP_STATS_ENTRY = 271,
    OF_HEADER = 272,
    OF_HELLO_ELEM = 273,
    OF_HELLO_ELEM_HEADER = 274,
    OF_HELLO_ELEM_VERSIONBITMAP = 275,
    OF_INSTRUCTION = 276,
    OF_INSTRUCTION_APPLY_ACTIONS = 277,
    OF_INSTRUCTION_BSN = 278,
    OF_INSTRUCTION_BSN_ARP_OFFLOAD = 279,
    OF_INSTRUCTION_BSN_DENY = 280,
    OF_INSTRUCTION_BSN_DHCP_OFFLOAD = 281,
    OF_INSTRUCTION_BSN_DISABLE_SPLIT_HORIZON_CHECK = 282,
    OF_INSTRUCTION_BSN_DISABLE_SRC_MAC_CHECK = 283,
    OF_INSTRUCTION_BSN_PERMIT = 284,
    OF_INSTRUCTION_CLEAR_ACTIONS = 285,
    OF_INSTRUCTION_EXPERIMENTER = 286,
    OF_INSTRUCTION_GOTO_TABLE = 287,
    OF_INSTRUCTION_HEADER = 288,
    OF_INSTRUCTION_ID = 289,
    OF_INSTRUCTION_ID_APPLY_ACTIONS = 290,
    OF_INSTRUCTION_ID_BSN = 291,
    OF_INSTRUCTION_ID_BSN_ARP_OFFLOAD = 292,
    OF_INSTRUCTION_ID_BSN_DENY = 293,
    OF_INSTRUCTION_ID_BSN_DHCP_OFFLOAD = 294,
    OF_INSTRUCTION_ID_BSN_DISABLE_SPLIT_HORIZON_CHECK = 295,
    OF_INSTRUCTION_ID_BSN_DISABLE_SRC_MAC_CHECK = 296,
    OF_INSTRUCTION_ID_BSN_PERMIT = 297,
    OF_INSTRUCTION_ID_CLEAR_ACTIONS = 298,
    OF_INSTRUCTION_ID_EXPERIMENTER = 299,
    OF_INSTRUCTION_ID_GOTO_TABLE = 300,
    OF_INSTRUCTION_ID_HEADER = 301,
    OF_INSTRUCTION_ID_METER = 302,
    OF_INSTRUCTION_ID_WRITE_ACTIONS = 303,
    OF_INSTRUCTION_ID_WRITE_METADATA = 304,
    OF_INSTRUCTION_METER = 305,
    OF_INSTRUCTION_WRITE_ACTIONS = 306,
    OF_INSTRUCTION_WRITE_METADATA = 307,
    OF_MATCH_V1 = 308,
    OF_MATCH_V2 = 309,
    OF_MATCH_V3 = 310,
    OF_METER_BAND = 311,
    OF_METER_BAND_DROP = 312,
    OF_METER_BAND_DSCP_REMARK = 313,
    OF_METER_BAND_EXPERIMENTER = 314,
    OF_METER_BAND_HEADER = 315,
    OF_METER_BAND_STATS = 316,
    OF_METER_CONFIG = 317,
    OF_METER_FEATURES = 318,
    OF_METER_STATS = 319,
    OF_OXM = 320,
    OF_OXM_ARP_OP = 321,
    OF_OXM_ARP_OP_MASKED = 322,
    OF_OXM_ARP_SHA = 323,
    OF_OXM_ARP_SHA_MASKED = 324,
    OF_OXM_ARP_SPA = 325,
    OF_OXM_ARP_SPA_MASKED = 326,
    OF_OXM_ARP_THA = 327,
    OF_OXM_ARP_THA_MASKED = 328,
    OF_OXM_ARP_TPA = 329,
    OF_OXM_ARP_TPA_MASKED = 330,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED = 331,
    OF_OXM_BSN_GLOBAL_VRF_ALLOWED_MASKED = 332,
    OF_OXM_BSN_IN_PORTS_128 = 333,
    OF_OXM_BSN_IN_PORTS_128_MASKED = 334,
    OF_OXM_BSN_L3_DST_CLASS_ID = 335,
    OF_OXM_BSN_L3_DST_CLASS_ID_MASKED = 336,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID = 337,
    OF_OXM_BSN_L3_INTERFACE_CLASS_ID_MASKED = 338,
    OF_OXM_BSN_L3_SRC_CLASS_ID = 339,
    OF_OXM_BSN_L3_SRC_CLASS_ID_MASKED = 340,
    OF_OXM_BSN_LAG_ID = 341,
    OF_OXM_BSN_LAG_ID_MASKED = 342,
    OF_OXM_BSN_VRF = 343,
    OF_OXM_BSN_VRF_MASKED = 344,
    OF_OXM_ETH_DST = 345,
    OF_OXM_ETH_DST_MASKED = 346,
    OF_OXM_ETH_SRC = 347,
    OF_OXM_ETH_SRC_MASKED = 348,
    OF_OXM_ETH_TYPE = 349,
    OF_OXM_ETH_TYPE_MASKED = 350,
    OF_OXM_HEADER = 351,
    OF_OXM_ICMPV4_CODE = 352,
    OF_OXM_ICMPV4_CODE_MASKED = 353,
    OF_OXM_ICMPV4_TYPE = 354,
    OF_OXM_ICMPV4_TYPE_MASKED = 355,
    OF_OXM_ICMPV6_CODE = 356,
    OF_OXM_ICMPV6_CODE_MASKED = 357,
    OF_OXM_ICMPV6_TYPE = 358,
    OF_OXM_ICMPV6_TYPE_MASKED = 359,
    OF_OXM_IN_PHY_PORT = 360,
    OF_OXM_IN_PHY_PORT_MASKED = 361,
    OF_OXM_IN_PORT = 362,
    OF_OXM_IN_PORT_MASKED = 363,
    OF_OXM_IP_DSCP = 364,
    OF_OXM_IP_DSCP_MASKED = 365,
    OF_OXM_IP_ECN = 366,
    OF_OXM_IP_ECN_MASKED = 367,
    OF_OXM_IP_PROTO = 368,
    OF_OXM_IP_PROTO_MASKED = 369,
    OF_OXM_IPV4_DST = 370,
    OF_OXM_IPV4_DST_MASKED = 371,
    OF_OXM_IPV4_SRC = 372,
    OF_OXM_IPV4_SRC_MASKED = 373,
    OF_OXM_IPV6_DST = 374,
    OF_OXM_IPV6_DST_MASKED = 375,
    OF_OXM_IPV6_FLABEL = 376,
    OF_OXM_IPV6_FLABEL_MASKED = 377,
    OF_OXM_IPV6_ND_SLL = 378,
    OF_OXM_IPV6_ND_SLL_MASKED = 379,
    OF_OXM_IPV6_ND_TARGET = 380,
    OF_OXM_IPV6_ND_TARGET_MASKED = 381,
    OF_OXM_IPV6_ND_TLL = 382,
    OF_OXM_IPV6_ND_TLL_MASKED = 383,
    OF_OXM_IPV6_SRC = 384,
    OF_OXM_IPV6_SRC_MASKED = 385,
    OF_OXM_METADATA = 386,
    OF_OXM_METADATA_MASKED = 387,
    OF_OXM_MPLS_LABEL = 388,
    OF_OXM_MPLS_LABEL_MASKED = 389,
    OF_OXM_MPLS_TC = 390,
    OF_OXM_MPLS_TC_MASKED = 391,
    OF_OXM_SCTP_DST = 392,
    OF_OXM_SCTP_DST_MASKED = 393,
    OF_OXM_SCTP_SRC = 394,
    OF_OXM_SCTP_SRC_MASKED = 395,
    OF_OXM_TCP_DST = 396,
    OF_OXM_TCP_DST_MASKED = 397,
    OF_OXM_TCP_SRC = 398,
    OF_OXM_TCP_SRC_MASKED = 399,
    OF_OXM_UDP_DST = 400,
    OF_OXM_UDP_DST_MASKED = 401,
    OF_OXM_UDP_SRC = 402,
    OF_OXM_UDP_SRC_MASKED = 403,
    OF_OXM_VLAN_PCP = 404,
    OF_OXM_VLAN_PCP_MASKED = 405,
    OF_OXM_VLAN_VID = 406,
    OF_OXM_VLAN_VID_MASKED = 407,
    OF_PACKET_QUEUE = 408,
    OF_PORT_DESC = 409,
    OF_PORT_STATS_ENTRY = 410,
    OF_QUEUE_PROP = 411,
    OF_QUEUE_PROP_EXPERIMENTER = 412,
    OF_QUEUE_PROP_HEADER = 413,
    OF_QUEUE_PROP_MAX_RATE = 414,
    OF_QUEUE_PROP_MIN_RATE = 415,
    OF_QUEUE_STATS_ENTRY = 416,
    OF_TABLE_FEATURE_PROP = 417,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS = 418,
    OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS = 419,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD = 420,
    OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS = 421,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER = 422,
    OF_TABLE_FEATURE_PROP_EXPERIMENTER_MISS = 423,
    OF_TABLE_FEATURE_PROP_HEADER = 424,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS = 425,
    OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS = 426,
    OF_TABLE_FEATURE_PROP_MATCH = 427,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES = 428,
    OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS = 429,
    OF_TABLE_FEATURE_PROP_WILDCARDS = 430,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS = 431,
    OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS = 432,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD = 433,
    OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS = 434,
    OF_TABLE_FEATURES = 435,
    OF_TABLE_STATS_ENTRY = 436,
    OF_UINT32 = 437,
    OF_UINT64 = 438,
    OF_UINT8 = 439,

    /* List objects */
    OF_LIST_ACTION = 440,
    OF_LIST_ACTION_ID = 441,
    OF_LIST_BSN_CONTROLLER_CONNECTION = 442,
    OF_LIST_BSN_FLOW_CHECKSUM_BUCKET_STATS_ENTRY = 443,
    OF_LIST_BSN_GENTABLE_BUCKET_STATS_ENTRY = 444,
    OF_LIST_BSN_GENTABLE_DESC_STATS_ENTRY = 445,
    OF_LIST_BSN_GENTABLE_ENTRY_DESC_STATS_ENTRY = 446,
    OF_LIST_BSN_GENTABLE_ENTRY_STATS_ENTRY = 447,
    OF_LIST_BSN_GENTABLE_STATS_ENTRY = 448,
    OF_LIST_BSN_INTERFACE = 449,
    OF_LIST_BSN_LACP_STATS_ENTRY = 450,
    OF_LIST_BSN_PORT_COUNTER_STATS_ENTRY = 451,
    OF_LIST_BSN_SWITCH_PIPELINE_STATS_ENTRY = 452,
    OF_LIST_BSN_TABLE_CHECKSUM_STATS_ENTRY = 453,
    OF_LIST_BSN_TLV = 454,
    OF_LIST_BSN_VLAN_COUNTER_STATS_ENTRY = 455,
    OF_LIST_BUCKET = 456,
    OF_LIST_BUCKET_COUNTER = 457,
    OF_LIST_FLOW_STATS_ENTRY = 458,
    OF_LIST_GROUP_DESC_STATS_ENTRY = 459,
    OF_LIST_GROUP_STATS_ENTRY = 460,
    OF_LIST_HELLO_ELEM = 461,
    OF_LIST_INSTRUCTION = 462,
    OF_LIST_INSTRUCTION_ID = 463,
    OF_LIST_METER_BAND = 464,
    OF_LIST_METER_BAND_STATS = 465,
    OF_LIST_METER_STATS = 466,
    OF_LIST_OXM = 467,
    OF_LIST_PACKET_QUEUE = 468,
    OF_LIST_PORT_DESC = 469,
    OF_LIST_PORT_STATS_ENTRY = 470,
    OF_LIST_QUEUE_PROP = 471,
    OF_LIST_QUEUE_STATS_ENTRY = 472,
    OF_LIST_TABLE_FEATURE_PROP = 473,
    OF_LIST_TABLE_FEATURES = 474,
    OF_LIST_TABLE_STATS_ENTRY = 475,
    OF_LIST_UINT32 = 476,
    OF_LIST_UINT64 = 477,
    OF_LIST_UINT8 = 478,

    /* Generic stats request/reply types; pseudo objects */

    OF_OBJECT_COUNT = 479
} of_object_id_t;

extern const char *const of_object_id_str[];

#define OF_MESSAGE_OBJECT_COUNT 172

/*
 * Macros to check if an object ID is within an inheritance class range
 */

#define OF_QUEUE_PROP_FIRST_ID      (OF_QUEUE_PROP + 1)
#define OF_QUEUE_PROP_LAST_ID       OF_QUEUE_PROP_MIN_RATE
#define OF_QUEUE_PROP_VALID_ID(id) \
    ((id) >= OF_QUEUE_PROP_FIRST_ID && \
     (id) <= OF_QUEUE_PROP_LAST_ID)

#define OF_ACTION_FIRST_ID      (OF_ACTION + 1)
#define OF_ACTION_LAST_ID       OF_ACTION_STRIP_VLAN
#define OF_ACTION_VALID_ID(id) \
    ((id) >= OF_ACTION_FIRST_ID && \
     (id) <= OF_ACTION_LAST_ID)

#define OF_INSTRUCTION_FIRST_ID      (OF_INSTRUCTION + 1)
#define OF_INSTRUCTION_LAST_ID       OF_INSTRUCTION_WRITE_METADATA
#define OF_INSTRUCTION_VALID_ID(id) \
    ((id) >= OF_INSTRUCTION_FIRST_ID && \
     (id) <= OF_INSTRUCTION_LAST_ID)

#define OF_TABLE_FEATURE_PROP_FIRST_ID      (OF_TABLE_FEATURE_PROP + 1)
#define OF_TABLE_FEATURE_PROP_LAST_ID       OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS
#define OF_TABLE_FEATURE_PROP_VALID_ID(id) \
    ((id) >= OF_TABLE_FEATURE_PROP_FIRST_ID && \
     (id) <= OF_TABLE_FEATURE_PROP_LAST_ID)

#define OF_OXM_FIRST_ID      (OF_OXM + 1)
#define OF_OXM_LAST_ID       OF_OXM_VLAN_VID_MASKED
#define OF_OXM_VALID_ID(id) \
    ((id) >= OF_OXM_FIRST_ID && \
     (id) <= OF_OXM_LAST_ID)

/**
 * Function to check a wire ID
 * @param object_id The ID to check
 * @param base_object_id The inheritance parent, if applicable
 * @returns boolean: If base_object_id is an inheritance class, check if
 * object_id is valid as a subclass.  Otherwise return 1.
 *
 * Note: Could check that object_id == base_object_id in the
 * second case.
 */
static inline int
of_wire_id_valid(int object_id, int base_object_id) {
    switch (base_object_id) {
    case OF_ACTION:
        return OF_ACTION_VALID_ID(object_id);
    case OF_OXM:
        return OF_OXM_VALID_ID(object_id);
    case OF_QUEUE_PROP:
        return OF_QUEUE_PROP_VALID_ID(object_id);
    case OF_TABLE_FEATURE_PROP:
        return OF_TABLE_FEATURE_PROP_VALID_ID(object_id);
    case OF_INSTRUCTION:
        return OF_INSTRUCTION_VALID_ID(object_id);
    default:
        break;
    }
    return 1;
}

/****************************************************************
 *
 * Experimenter IDs
 *
 ****************************************************************/

#define OF_EXPERIMENTER_ID_OPENFLOW 0x000026e1
#define OF_EXPERIMENTER_ID_NICIRA 0x00002320
#define OF_EXPERIMENTER_ID_BSN 0x005c16c7

/****************************************************************
 *
 * OpenFlow Match version specific and generic defines
 *
 ****************************************************************/

/**
 * Definitions to coerce v4 match (version 1.3) to v3 matches
 * (version 1.2).
 * @FIXME This is a stopgap and needs to get cleaned up.
 */
#define of_match_v4_t of_match_v3_t
#define of_match_v4_init of_match_v3_init
#define of_match_v4_new of_match_v3_new
#define of_match_v4_to_match of_match_v3_to_match
#define of_match_to_wire_match_v4 of_match_to_wire_match_v3
#define of_match_v4_delete of_match_v3_delete


/**
 * Definitions for wildcard macros for OF_VERSION_1_0
 */


#define OF_MATCH_V1_WC_ETH_DST_SHIFT 3
#define OF_MATCH_V1_WC_ETH_DST_MASK (1 << 3)
#define OF_MATCH_V1_WC_ETH_DST_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V1_WC_ETH_DST_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V1_WC_ETH_SRC_SHIFT 2
#define OF_MATCH_V1_WC_ETH_SRC_MASK (1 << 2)
#define OF_MATCH_V1_WC_ETH_SRC_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V1_WC_ETH_SRC_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V1_WC_ETH_TYPE_SHIFT 4
#define OF_MATCH_V1_WC_ETH_TYPE_MASK (1 << 4)
#define OF_MATCH_V1_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V1_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V1_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V1_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V1_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V1_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V1_WC_IPV4_DST_SHIFT 14
#define OF_MATCH_V1_WC_IPV4_DST_MASK (0x3f << 14)
#define OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc) ((wc) &= ~(0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_DST_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 14)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_DST_TEST(wc) ((wc) & (0x3f << 14))
#define OF_MATCH_V1_WC_IPV4_DST_GET(wc) (((wc) >> 14) & 0x3f)

#define OF_MATCH_V1_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V1_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V1_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V1_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V1_WC_IPV4_SRC_SHIFT 8
#define OF_MATCH_V1_WC_IPV4_SRC_MASK (0x3f << 8)
#define OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc) ((wc) &= ~(0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_SET(wc, value) do {   \
        OF_MATCH_V1_WC_IPV4_SRC_CLEAR(wc); \
        ((wc) |= (((value) & 0x3f) << 8)); \
    } while (0)
#define OF_MATCH_V1_WC_IPV4_SRC_TEST(wc) ((wc) & (0x3f << 8))
#define OF_MATCH_V1_WC_IPV4_SRC_GET(wc) (((wc) >> 8) & 0x3f)

#define OF_MATCH_V1_WC_IP_DSCP_SHIFT 21
#define OF_MATCH_V1_WC_IP_DSCP_MASK (1 << 21)
#define OF_MATCH_V1_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 21))
#define OF_MATCH_V1_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 21))

#define OF_MATCH_V1_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V1_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V1_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V1_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V1_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V1_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V1_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V1_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V1_WC_VLAN_PCP_SHIFT 20
#define OF_MATCH_V1_WC_VLAN_PCP_MASK (1 << 20)
#define OF_MATCH_V1_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 20))
#define OF_MATCH_V1_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 20))

#define OF_MATCH_V1_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V1_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V1_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V1_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))


/**
 * Definitions for wildcard macros for OF_VERSION_1_1
 */

#define OF_MATCH_V2_WC_ETH_TYPE_SHIFT 3
#define OF_MATCH_V2_WC_ETH_TYPE_MASK (1 << 3)
#define OF_MATCH_V2_WC_ETH_TYPE_SET(wc) ((wc) |= (1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_CLEAR(wc) ((wc) &= ~(1 << 3))
#define OF_MATCH_V2_WC_ETH_TYPE_TEST(wc) ((wc) & (1 << 3))

#define OF_MATCH_V2_WC_IN_PORT_SHIFT 0
#define OF_MATCH_V2_WC_IN_PORT_MASK (1 << 0)
#define OF_MATCH_V2_WC_IN_PORT_SET(wc) ((wc) |= (1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_CLEAR(wc) ((wc) &= ~(1 << 0))
#define OF_MATCH_V2_WC_IN_PORT_TEST(wc) ((wc) & (1 << 0))

#define OF_MATCH_V2_WC_IP_DSCP_SHIFT 4
#define OF_MATCH_V2_WC_IP_DSCP_MASK (1 << 4)
#define OF_MATCH_V2_WC_IP_DSCP_SET(wc) ((wc) |= (1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_CLEAR(wc) ((wc) &= ~(1 << 4))
#define OF_MATCH_V2_WC_IP_DSCP_TEST(wc) ((wc) & (1 << 4))

#define OF_MATCH_V2_WC_IP_PROTO_SHIFT 5
#define OF_MATCH_V2_WC_IP_PROTO_MASK (1 << 5)
#define OF_MATCH_V2_WC_IP_PROTO_SET(wc) ((wc) |= (1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_CLEAR(wc) ((wc) &= ~(1 << 5))
#define OF_MATCH_V2_WC_IP_PROTO_TEST(wc) ((wc) & (1 << 5))

#define OF_MATCH_V2_WC_MPLS_LABEL_SHIFT 8
#define OF_MATCH_V2_WC_MPLS_LABEL_MASK (1 << 8)
#define OF_MATCH_V2_WC_MPLS_LABEL_SET(wc) ((wc) |= (1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_CLEAR(wc) ((wc) &= ~(1 << 8))
#define OF_MATCH_V2_WC_MPLS_LABEL_TEST(wc) ((wc) & (1 << 8))

#define OF_MATCH_V2_WC_MPLS_TC_SHIFT 9
#define OF_MATCH_V2_WC_MPLS_TC_MASK (1 << 9)
#define OF_MATCH_V2_WC_MPLS_TC_SET(wc) ((wc) |= (1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_CLEAR(wc) ((wc) &= ~(1 << 9))
#define OF_MATCH_V2_WC_MPLS_TC_TEST(wc) ((wc) & (1 << 9))

#define OF_MATCH_V2_WC_TCP_DST_SHIFT 7
#define OF_MATCH_V2_WC_TCP_DST_MASK (1 << 7)
#define OF_MATCH_V2_WC_TCP_DST_SET(wc) ((wc) |= (1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_CLEAR(wc) ((wc) &= ~(1 << 7))
#define OF_MATCH_V2_WC_TCP_DST_TEST(wc) ((wc) & (1 << 7))

#define OF_MATCH_V2_WC_TCP_SRC_SHIFT 6
#define OF_MATCH_V2_WC_TCP_SRC_MASK (1 << 6)
#define OF_MATCH_V2_WC_TCP_SRC_SET(wc) ((wc) |= (1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_CLEAR(wc) ((wc) &= ~(1 << 6))
#define OF_MATCH_V2_WC_TCP_SRC_TEST(wc) ((wc) & (1 << 6))

#define OF_MATCH_V2_WC_VLAN_PCP_SHIFT 2
#define OF_MATCH_V2_WC_VLAN_PCP_MASK (1 << 2)
#define OF_MATCH_V2_WC_VLAN_PCP_SET(wc) ((wc) |= (1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_CLEAR(wc) ((wc) &= ~(1 << 2))
#define OF_MATCH_V2_WC_VLAN_PCP_TEST(wc) ((wc) & (1 << 2))

#define OF_MATCH_V2_WC_VLAN_VID_SHIFT 1
#define OF_MATCH_V2_WC_VLAN_VID_MASK (1 << 1)
#define OF_MATCH_V2_WC_VLAN_VID_SET(wc) ((wc) |= (1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_CLEAR(wc) ((wc) &= ~(1 << 1))
#define OF_MATCH_V2_WC_VLAN_VID_TEST(wc) ((wc) & (1 << 1))


/* These are from the OpenFlow 1.2 header file */

/* OXM index values for bitmaps and parsing */
enum of_oxm_index_e {
    OF_OXM_INDEX_IN_PORT        = 0,  /* Switch input port. */
    OF_OXM_INDEX_IN_PHY_PORT    = 1,  /* Switch physical input port. */
    OF_OXM_INDEX_METADATA       = 2,  /* Metadata passed between tables. */
    OF_OXM_INDEX_ETH_DST        = 3,  /* Ethernet destination address. */
    OF_OXM_INDEX_ETH_SRC        = 4,  /* Ethernet source address. */
    OF_OXM_INDEX_ETH_TYPE       = 5,  /* Ethernet frame type. */
    OF_OXM_INDEX_VLAN_VID       = 6,  /* VLAN id. */
    OF_OXM_INDEX_VLAN_PCP       = 7,  /* VLAN priority. */
    OF_OXM_INDEX_IP_DSCP        = 8,  /* IP DSCP (6 bits in ToS field). */
    OF_OXM_INDEX_IP_ECN         = 9,  /* IP ECN (2 bits in ToS field). */
    OF_OXM_INDEX_IP_PROTO       = 10, /* IP protocol. */
    OF_OXM_INDEX_IPV4_SRC       = 11, /* IPv4 source address. */
    OF_OXM_INDEX_IPV4_DST       = 12, /* IPv4 destination address. */
    OF_OXM_INDEX_TCP_SRC        = 13, /* TCP source port. */
    OF_OXM_INDEX_TCP_DST        = 14, /* TCP destination port. */
    OF_OXM_INDEX_UDP_SRC        = 15, /* UDP source port. */
    OF_OXM_INDEX_UDP_DST        = 16, /* UDP destination port. */
    OF_OXM_INDEX_SCTP_SRC       = 17, /* SCTP source port. */
    OF_OXM_INDEX_SCTP_DST       = 18, /* SCTP destination port. */
    OF_OXM_INDEX_ICMPV4_TYPE    = 19, /* ICMP type. */
    OF_OXM_INDEX_ICMPV4_CODE    = 20, /* ICMP code. */
    OF_OXM_INDEX_ARP_OP         = 21, /* ARP opcode. */
    OF_OXM_INDEX_ARP_SPA        = 22, /* ARP source IPv4 address. */
    OF_OXM_INDEX_ARP_TPA        = 23, /* ARP target IPv4 address. */
    OF_OXM_INDEX_ARP_SHA        = 24, /* ARP source hardware address. */
    OF_OXM_INDEX_ARP_THA        = 25, /* ARP target hardware address. */
    OF_OXM_INDEX_IPV6_SRC       = 26, /* IPv6 source address. */
    OF_OXM_INDEX_IPV6_DST       = 27, /* IPv6 destination address. */
    OF_OXM_INDEX_IPV6_FLABEL    = 28, /* IPv6 Flow Label */
    OF_OXM_INDEX_ICMPV6_TYPE    = 29, /* ICMPv6 type. */
    OF_OXM_INDEX_ICMPV6_CODE    = 30, /* ICMPv6 code. */
    OF_OXM_INDEX_IPV6_ND_TARGET = 31, /* Target address for ND. */
    OF_OXM_INDEX_IPV6_ND_SLL    = 32, /* Source link-layer for ND. */
    OF_OXM_INDEX_IPV6_ND_TLL    = 33, /* Target link-layer for ND. */
    OF_OXM_INDEX_MPLS_LABEL     = 34, /* MPLS label. */
    OF_OXM_INDEX_MPLS_TC        = 35, /* MPLS TC. */

    OF_OXM_INDEX_BSN_IN_PORTS_128 = 36,
    OF_OXM_INDEX_BSN_LAG_ID = 37,
    OF_OXM_INDEX_BSN_VRF = 38,
    OF_OXM_INDEX_BSN_GLOBAL_VRF_ALLOWED = 39,
    OF_OXM_INDEX_BSN_L3_INTERFACE_CLASS_ID = 40,
    OF_OXM_INDEX_BSN_L3_SRC_CLASS_ID = 41,
    OF_OXM_INDEX_BSN_L3_DST_CLASS_ID = 42,
};

#define OF_OXM_BIT(index) (((uint64_t) 1) << (index))

/*
 * The generic match structure uses the OXM bit indices for it's
 * bitmasks for active and masked values
 */

/* Mask/value check/set macros for ipv6_flabel */

/**
 * Set the mask for an exact match of ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_flabel, 0xff, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Clear the mask for ipv6_flabel making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_flabel, 0, \
        sizeof(((_match)->masks).ipv6_flabel))

/**
 * Test whether the match is exact for ipv6_flabel
 */
#define OF_MATCH_MASK_IPV6_FLABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_flabel))

/**
 * Test whether key ipv6_flabel is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_flabel))


/* Mask/value check/set macros for bsn_lag_id */

/**
 * Set the mask for an exact match of bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_lag_id, 0xff, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Clear the mask for bsn_lag_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_lag_id, 0, \
        sizeof(((_match)->masks).bsn_lag_id))

/**
 * Test whether the match is exact for bsn_lag_id
 */
#define OF_MATCH_MASK_BSN_LAG_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_lag_id))

/**
 * Test whether key bsn_lag_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_LAG_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_lag_id))


/* Mask/value check/set macros for vlan_pcp */

/**
 * Set the mask for an exact match of vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_pcp, 0xff, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Clear the mask for vlan_pcp making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_PCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_pcp, 0, \
        sizeof(((_match)->masks).vlan_pcp))

/**
 * Test whether the match is exact for vlan_pcp
 */
#define OF_MATCH_MASK_VLAN_PCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_pcp))

/**
 * Test whether key vlan_pcp is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_pcp))


/* Mask/value check/set macros for ipv4_src */

/**
 * Set the mask for an exact match of ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_src, 0xff, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Clear the mask for ipv4_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_src, 0, \
        sizeof(((_match)->masks).ipv4_src))

/**
 * Test whether the match is exact for ipv4_src
 */
#define OF_MATCH_MASK_IPV4_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_src))

/**
 * Test whether key ipv4_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_src))


/* Mask/value check/set macros for ipv6_dst */

/**
 * Set the mask for an exact match of ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_dst, 0xff, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Clear the mask for ipv6_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_dst, 0, \
        sizeof(((_match)->masks).ipv6_dst))

/**
 * Test whether the match is exact for ipv6_dst
 */
#define OF_MATCH_MASK_IPV6_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_dst))

/**
 * Test whether key ipv6_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_dst))


/* Mask/value check/set macros for arp_tpa */

/**
 * Set the mask for an exact match of arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tpa, 0xff, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Clear the mask for arp_tpa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_TPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tpa, 0, \
        sizeof(((_match)->masks).arp_tpa))

/**
 * Test whether the match is exact for arp_tpa
 */
#define OF_MATCH_MASK_ARP_TPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tpa))

/**
 * Test whether key arp_tpa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tpa))


/* Mask/value check/set macros for icmpv6_type */

/**
 * Set the mask for an exact match of icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_type, 0xff, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Clear the mask for icmpv6_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_type, 0, \
        sizeof(((_match)->masks).icmpv6_type))

/**
 * Test whether the match is exact for icmpv6_type
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_type))

/**
 * Test whether key icmpv6_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_type))


/* Mask/value check/set macros for bsn_in_ports_128 */

/**
 * Set the mask for an exact match of bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0xff, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Clear the mask for bsn_in_ports_128 making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_in_ports_128, 0, \
        sizeof(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether the match is exact for bsn_in_ports_128
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_in_ports_128))

/**
 * Test whether key bsn_in_ports_128 is being checked in the match
 */
#define OF_MATCH_MASK_BSN_IN_PORTS_128_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_in_ports_128))


/* Mask/value check/set macros for arp_sha */

/**
 * Set the mask for an exact match of arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_sha, 0xff, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Clear the mask for arp_sha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SHA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_sha, 0, \
        sizeof(((_match)->masks).arp_sha))

/**
 * Test whether the match is exact for arp_sha
 */
#define OF_MATCH_MASK_ARP_SHA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_sha))

/**
 * Test whether key arp_sha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_sha))


/* Mask/value check/set macros for ipv6_src */

/**
 * Set the mask for an exact match of ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_src, 0xff, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Clear the mask for ipv6_src making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_src, 0, \
        sizeof(((_match)->masks).ipv6_src))

/**
 * Test whether the match is exact for ipv6_src
 */
#define OF_MATCH_MASK_IPV6_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_src))

/**
 * Test whether key ipv6_src is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_src))


/* Mask/value check/set macros for sctp_src */

/**
 * Set the mask for an exact match of sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_src, 0xff, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Clear the mask for sctp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_src, 0, \
        sizeof(((_match)->masks).sctp_src))

/**
 * Test whether the match is exact for sctp_src
 */
#define OF_MATCH_MASK_SCTP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_src))

/**
 * Test whether key sctp_src is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_src))


/* Mask/value check/set macros for icmpv6_code */

/**
 * Set the mask for an exact match of icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv6_code, 0xff, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Clear the mask for icmpv6_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv6_code, 0, \
        sizeof(((_match)->masks).icmpv6_code))

/**
 * Test whether the match is exact for icmpv6_code
 */
#define OF_MATCH_MASK_ICMPV6_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv6_code))

/**
 * Test whether key icmpv6_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv6_code))


/* Mask/value check/set macros for eth_dst */

/**
 * Set the mask for an exact match of eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_dst, 0xff, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Clear the mask for eth_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_dst, 0, \
        sizeof(((_match)->masks).eth_dst))

/**
 * Test whether the match is exact for eth_dst
 */
#define OF_MATCH_MASK_ETH_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_dst))

/**
 * Test whether key eth_dst is being checked in the match
 */
#define OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_dst))


/* Mask/value check/set macros for ipv6_nd_sll */

/**
 * Set the mask for an exact match of ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Clear the mask for ipv6_nd_sll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_sll, 0, \
        sizeof(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether the match is exact for ipv6_nd_sll
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_sll))

/**
 * Test whether key ipv6_nd_sll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_sll))


/* Mask/value check/set macros for mpls_tc */

/**
 * Set the mask for an exact match of mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_tc, 0xff, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Clear the mask for mpls_tc making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_TC_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_tc, 0, \
        sizeof(((_match)->masks).mpls_tc))

/**
 * Test whether the match is exact for mpls_tc
 */
#define OF_MATCH_MASK_MPLS_TC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_tc))

/**
 * Test whether key mpls_tc is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_tc))


/* Mask/value check/set macros for arp_op */

/**
 * Set the mask for an exact match of arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_op, 0xff, \
        sizeof(((_match)->masks).arp_op))

/**
 * Clear the mask for arp_op making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_OP_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_op, 0, \
        sizeof(((_match)->masks).arp_op))

/**
 * Test whether the match is exact for arp_op
 */
#define OF_MATCH_MASK_ARP_OP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_op))

/**
 * Test whether key arp_op is being checked in the match
 */
#define OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_op))


/* Mask/value check/set macros for eth_type */

/**
 * Set the mask for an exact match of eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_type, 0xff, \
        sizeof(((_match)->masks).eth_type))

/**
 * Clear the mask for eth_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_type, 0, \
        sizeof(((_match)->masks).eth_type))

/**
 * Test whether the match is exact for eth_type
 */
#define OF_MATCH_MASK_ETH_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_type))

/**
 * Test whether key eth_type is being checked in the match
 */
#define OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_type))


/* Mask/value check/set macros for ipv6_nd_target */

/**
 * Set the mask for an exact match of ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Clear the mask for ipv6_nd_target making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_target, 0, \
        sizeof(((_match)->masks).ipv6_nd_target))

/**
 * Test whether the match is exact for ipv6_nd_target
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_target))

/**
 * Test whether key ipv6_nd_target is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_target))


/* Mask/value check/set macros for vlan_vid */

/**
 * Set the mask for an exact match of vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.vlan_vid, 0xff, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Clear the mask for vlan_vid making that field inactive for the match
 */
#define OF_MATCH_MASK_VLAN_VID_CLEAR(_match) \
    MEMSET(&(_match)->masks.vlan_vid, 0, \
        sizeof(((_match)->masks).vlan_vid))

/**
 * Test whether the match is exact for vlan_vid
 */
#define OF_MATCH_MASK_VLAN_VID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).vlan_vid))

/**
 * Test whether key vlan_vid is being checked in the match
 */
#define OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).vlan_vid))


/* Mask/value check/set macros for arp_tha */

/**
 * Set the mask for an exact match of arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_tha, 0xff, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Clear the mask for arp_tha making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_THA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_tha, 0, \
        sizeof(((_match)->masks).arp_tha))

/**
 * Test whether the match is exact for arp_tha
 */
#define OF_MATCH_MASK_ARP_THA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_tha))

/**
 * Test whether key arp_tha is being checked in the match
 */
#define OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_tha))


/* Mask/value check/set macros for in_port */

/**
 * Set the mask for an exact match of in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_port, 0xff, \
        sizeof(((_match)->masks).in_port))

/**
 * Clear the mask for in_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_port, 0, \
        sizeof(((_match)->masks).in_port))

/**
 * Test whether the match is exact for in_port
 */
#define OF_MATCH_MASK_IN_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_port))

/**
 * Test whether key in_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_port))


/* Mask/value check/set macros for metadata */

/**
 * Set the mask for an exact match of metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.metadata, 0xff, \
        sizeof(((_match)->masks).metadata))

/**
 * Clear the mask for metadata making that field inactive for the match
 */
#define OF_MATCH_MASK_METADATA_CLEAR(_match) \
    MEMSET(&(_match)->masks.metadata, 0, \
        sizeof(((_match)->masks).metadata))

/**
 * Test whether the match is exact for metadata
 */
#define OF_MATCH_MASK_METADATA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).metadata))

/**
 * Test whether key metadata is being checked in the match
 */
#define OF_MATCH_MASK_METADATA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).metadata))


/* Mask/value check/set macros for bsn_l3_src_class_id */

/**
 * Set the mask for an exact match of bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Clear the mask for bsn_l3_src_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_src_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether the match is exact for bsn_l3_src_class_id
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_src_class_id))

/**
 * Test whether key bsn_l3_src_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_SRC_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_src_class_id))


/* Mask/value check/set macros for sctp_dst */

/**
 * Set the mask for an exact match of sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.sctp_dst, 0xff, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Clear the mask for sctp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_SCTP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.sctp_dst, 0, \
        sizeof(((_match)->masks).sctp_dst))

/**
 * Test whether the match is exact for sctp_dst
 */
#define OF_MATCH_MASK_SCTP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).sctp_dst))

/**
 * Test whether key sctp_dst is being checked in the match
 */
#define OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).sctp_dst))


/* Mask/value check/set macros for icmpv4_code */

/**
 * Set the mask for an exact match of icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_code, 0xff, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Clear the mask for icmpv4_code making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_code, 0, \
        sizeof(((_match)->masks).icmpv4_code))

/**
 * Test whether the match is exact for icmpv4_code
 */
#define OF_MATCH_MASK_ICMPV4_CODE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_code))

/**
 * Test whether key icmpv4_code is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_code))


/* Mask/value check/set macros for tcp_src */

/**
 * Set the mask for an exact match of tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_src, 0xff, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Clear the mask for tcp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_src, 0, \
        sizeof(((_match)->masks).tcp_src))

/**
 * Test whether the match is exact for tcp_src
 */
#define OF_MATCH_MASK_TCP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_src))

/**
 * Test whether key tcp_src is being checked in the match
 */
#define OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_src))


/* Mask/value check/set macros for bsn_vrf */

/**
 * Set the mask for an exact match of bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_vrf, 0xff, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Clear the mask for bsn_vrf making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_VRF_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_vrf, 0, \
        sizeof(((_match)->masks).bsn_vrf))

/**
 * Test whether the match is exact for bsn_vrf
 */
#define OF_MATCH_MASK_BSN_VRF_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_vrf))

/**
 * Test whether key bsn_vrf is being checked in the match
 */
#define OF_MATCH_MASK_BSN_VRF_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_vrf))


/* Mask/value check/set macros for ip_ecn */

/**
 * Set the mask for an exact match of ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_ecn, 0xff, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Clear the mask for ip_ecn making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_ECN_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_ecn, 0, \
        sizeof(((_match)->masks).ip_ecn))

/**
 * Test whether the match is exact for ip_ecn
 */
#define OF_MATCH_MASK_IP_ECN_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_ecn))

/**
 * Test whether key ip_ecn is being checked in the match
 */
#define OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_ecn))


/* Mask/value check/set macros for bsn_global_vrf_allowed */

/**
 * Set the mask for an exact match of bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0xff, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Clear the mask for bsn_global_vrf_allowed making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_global_vrf_allowed, 0, \
        sizeof(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether the match is exact for bsn_global_vrf_allowed
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_global_vrf_allowed))

/**
 * Test whether key bsn_global_vrf_allowed is being checked in the match
 */
#define OF_MATCH_MASK_BSN_GLOBAL_VRF_ALLOWED_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_global_vrf_allowed))


/* Mask/value check/set macros for udp_dst */

/**
 * Set the mask for an exact match of udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_dst, 0xff, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Clear the mask for udp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_dst, 0, \
        sizeof(((_match)->masks).udp_dst))

/**
 * Test whether the match is exact for udp_dst
 */
#define OF_MATCH_MASK_UDP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_dst))

/**
 * Test whether key udp_dst is being checked in the match
 */
#define OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_dst))


/* Mask/value check/set macros for arp_spa */

/**
 * Set the mask for an exact match of arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.arp_spa, 0xff, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Clear the mask for arp_spa making that field inactive for the match
 */
#define OF_MATCH_MASK_ARP_SPA_CLEAR(_match) \
    MEMSET(&(_match)->masks.arp_spa, 0, \
        sizeof(((_match)->masks).arp_spa))

/**
 * Test whether the match is exact for arp_spa
 */
#define OF_MATCH_MASK_ARP_SPA_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).arp_spa))

/**
 * Test whether key arp_spa is being checked in the match
 */
#define OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).arp_spa))


/* Mask/value check/set macros for in_phy_port */

/**
 * Set the mask for an exact match of in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.in_phy_port, 0xff, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Clear the mask for in_phy_port making that field inactive for the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_CLEAR(_match) \
    MEMSET(&(_match)->masks.in_phy_port, 0, \
        sizeof(((_match)->masks).in_phy_port))

/**
 * Test whether the match is exact for in_phy_port
 */
#define OF_MATCH_MASK_IN_PHY_PORT_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).in_phy_port))

/**
 * Test whether key in_phy_port is being checked in the match
 */
#define OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).in_phy_port))


/* Mask/value check/set macros for ipv4_dst */

/**
 * Set the mask for an exact match of ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv4_dst, 0xff, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Clear the mask for ipv4_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV4_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv4_dst, 0, \
        sizeof(((_match)->masks).ipv4_dst))

/**
 * Test whether the match is exact for ipv4_dst
 */
#define OF_MATCH_MASK_IPV4_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv4_dst))

/**
 * Test whether key ipv4_dst is being checked in the match
 */
#define OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv4_dst))


/* Mask/value check/set macros for eth_src */

/**
 * Set the mask for an exact match of eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.eth_src, 0xff, \
        sizeof(((_match)->masks).eth_src))

/**
 * Clear the mask for eth_src making that field inactive for the match
 */
#define OF_MATCH_MASK_ETH_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.eth_src, 0, \
        sizeof(((_match)->masks).eth_src))

/**
 * Test whether the match is exact for eth_src
 */
#define OF_MATCH_MASK_ETH_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).eth_src))

/**
 * Test whether key eth_src is being checked in the match
 */
#define OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).eth_src))


/* Mask/value check/set macros for udp_src */

/**
 * Set the mask for an exact match of udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.udp_src, 0xff, \
        sizeof(((_match)->masks).udp_src))

/**
 * Clear the mask for udp_src making that field inactive for the match
 */
#define OF_MATCH_MASK_UDP_SRC_CLEAR(_match) \
    MEMSET(&(_match)->masks.udp_src, 0, \
        sizeof(((_match)->masks).udp_src))

/**
 * Test whether the match is exact for udp_src
 */
#define OF_MATCH_MASK_UDP_SRC_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).udp_src))

/**
 * Test whether key udp_src is being checked in the match
 */
#define OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).udp_src))


/* Mask/value check/set macros for bsn_l3_dst_class_id */

/**
 * Set the mask for an exact match of bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Clear the mask for bsn_l3_dst_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_dst_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether the match is exact for bsn_l3_dst_class_id
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_dst_class_id))

/**
 * Test whether key bsn_l3_dst_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_DST_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_dst_class_id))


/* Mask/value check/set macros for ipv6_nd_tll */

/**
 * Set the mask for an exact match of ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0xff, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Clear the mask for ipv6_nd_tll making that field inactive for the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_CLEAR(_match) \
    MEMSET(&(_match)->masks.ipv6_nd_tll, 0, \
        sizeof(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether the match is exact for ipv6_nd_tll
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ipv6_nd_tll))

/**
 * Test whether key ipv6_nd_tll is being checked in the match
 */
#define OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ipv6_nd_tll))


/* Mask/value check/set macros for icmpv4_type */

/**
 * Set the mask for an exact match of icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.icmpv4_type, 0xff, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Clear the mask for icmpv4_type making that field inactive for the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_CLEAR(_match) \
    MEMSET(&(_match)->masks.icmpv4_type, 0, \
        sizeof(((_match)->masks).icmpv4_type))

/**
 * Test whether the match is exact for icmpv4_type
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).icmpv4_type))

/**
 * Test whether key icmpv4_type is being checked in the match
 */
#define OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).icmpv4_type))


/* Mask/value check/set macros for mpls_label */

/**
 * Set the mask for an exact match of mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.mpls_label, 0xff, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Clear the mask for mpls_label making that field inactive for the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_CLEAR(_match) \
    MEMSET(&(_match)->masks.mpls_label, 0, \
        sizeof(((_match)->masks).mpls_label))

/**
 * Test whether the match is exact for mpls_label
 */
#define OF_MATCH_MASK_MPLS_LABEL_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).mpls_label))

/**
 * Test whether key mpls_label is being checked in the match
 */
#define OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).mpls_label))


/* Mask/value check/set macros for tcp_dst */

/**
 * Set the mask for an exact match of tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.tcp_dst, 0xff, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Clear the mask for tcp_dst making that field inactive for the match
 */
#define OF_MATCH_MASK_TCP_DST_CLEAR(_match) \
    MEMSET(&(_match)->masks.tcp_dst, 0, \
        sizeof(((_match)->masks).tcp_dst))

/**
 * Test whether the match is exact for tcp_dst
 */
#define OF_MATCH_MASK_TCP_DST_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).tcp_dst))

/**
 * Test whether key tcp_dst is being checked in the match
 */
#define OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).tcp_dst))


/* Mask/value check/set macros for ip_proto */

/**
 * Set the mask for an exact match of ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_proto, 0xff, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Clear the mask for ip_proto making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_PROTO_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_proto, 0, \
        sizeof(((_match)->masks).ip_proto))

/**
 * Test whether the match is exact for ip_proto
 */
#define OF_MATCH_MASK_IP_PROTO_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_proto))

/**
 * Test whether key ip_proto is being checked in the match
 */
#define OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_proto))


/* Mask/value check/set macros for bsn_l3_interface_class_id */

/**
 * Set the mask for an exact match of bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0xff, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Clear the mask for bsn_l3_interface_class_id making that field inactive for the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_CLEAR(_match) \
    MEMSET(&(_match)->masks.bsn_l3_interface_class_id, 0, \
        sizeof(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether the match is exact for bsn_l3_interface_class_id
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).bsn_l3_interface_class_id))

/**
 * Test whether key bsn_l3_interface_class_id is being checked in the match
 */
#define OF_MATCH_MASK_BSN_L3_INTERFACE_CLASS_ID_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).bsn_l3_interface_class_id))


/* Mask/value check/set macros for ip_dscp */

/**
 * Set the mask for an exact match of ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_SET(_match)   \
    MEMSET(&(_match)->masks.ip_dscp, 0xff, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Clear the mask for ip_dscp making that field inactive for the match
 */
#define OF_MATCH_MASK_IP_DSCP_CLEAR(_match) \
    MEMSET(&(_match)->masks.ip_dscp, 0, \
        sizeof(((_match)->masks).ip_dscp))

/**
 * Test whether the match is exact for ip_dscp
 */
#define OF_MATCH_MASK_IP_DSCP_EXACT_TEST(_match) \
    OF_VARIABLE_IS_ALL_ONES(&(((_match)->masks).ip_dscp))

/**
 * Test whether key ip_dscp is being checked in the match
 */
#define OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(_match) \
    OF_VARIABLE_IS_NON_ZERO(&(((_match)->masks).ip_dscp))


#endif /* Base header file */
